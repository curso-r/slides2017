<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="J" />

<meta name="date" content="2017-02-15" />

<title>Web scraping</title>

<script src="aula8_files/jquery/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="aula8_files/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
<script src="aula8_files/bootstrap/js/bootstrap.min.js"></script>
<script src="aula8_files/bootstrap/shim/html5shiv.min.js"></script>
<script src="aula8_files/bootstrap/shim/respond.min.js"></script>
<script src="aula8_files/navigation/tabsets.js"></script>
<link href="aula8_files/highlightjs/default.css" rel="stylesheet" />
<script src="aula8_files/highlightjs/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>



<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Web scraping</h1>
<h4 class="author"><em>J</em></h4>
<h4 class="date"><em>February 15, 2017</em></h4>

</div>


<div id="pacotes-httr-xml2-e-rvest" class="section level2">
<h2>Pacotes <code>httr</code>, <code>xml2</code> e <code>rvest</code></h2>
<p>Esses são os três pacotes mais modernos do R utilizados para fazer web scraping. O pacote <code>xml2</code> tem a finalidade de estruturar arquivos HTML ou XML de forma eficiente, tornando possível a obtenção de <em>tags</em> e seus atributos dentro de um arquivo. Já o pacote <code>httr</code> é responsável por realizar requisições web para obtenção das páginas de interesse, buscando reduzir ao máximo a complexidade da programação. O pacote <code>rvest</code> é escrito <strong>sobre</strong> os dois anteriores e por isso eleva ainda mais o nível de especialização para raspagem de dados.</p>
<p>As características dos pacotes implicam na seguinte regra de bolso. Para trabalhar com páginas simples, basta carregar o <code>rvest</code> e utilizar suas funcionalidades. Caso o acesso à página exija ações mais complexas e/ou artifícios de ferramentas web, será necessário utilizar o <code>httr</code>. O <code>xml2</code> só será usado explicitamente nos casos raros em que a página está em XML, que pode ser visto como uma generalização do HTML.</p>
<p>Esses pacotes não são suficientes para acessar todo tipo de conteúdo da web. Um exemplo claro disso são páginas em que o conteúdo é produzido por <code>javascript</code>, o que acontece em muitos sites modernos. Para trabalhar com esses sites, é necessário realmente “simular” um navegador que acessa a página web. Uma das melhores ferramentas para isso é o <code>selenium</code>. Não discutiremos <code>selenium</code> nesse curso, mas caso queira se aprofundar, acesse <a href="http://www.seleniumhq.org/">aqui</a>.</p>
<div id="sessoes-e-cookies" class="section level3">
<h3>Sessões e cookies</h3>
<p>No momento que acessamos uma página web, nosso navegador baixa alguns arquivos que “identificam” nosso acesso à página. Esses arquivos são chamados cookies e são usados pelos sites para realizar diversas atividades, como carregar uma página pré-definida pelo usuário caso este acesse o site pela segunda vez.</p>
<p>O <code>httr</code> e por consequência o <code>rvest</code> já guardam esses cookies de forma automática, de forma que o usuário não precise se preocupar com isso. Em casos raros, para construir o web scraper é necessário modificar esses cookies. Nesses casos, estude a função <code>cookies()</code> do <code>httr</code>.</p>
</div>
<div id="get-e-post" class="section level3">
<h3><code>GET</code> e <code>POST</code></h3>
<p>Uma requisição <strong>GET</strong> envia uma <code>url</code> ao servidor, possivelmente com alguns parâmetros nessa <code>url</code> (que ficam no final da <code>url</code> depois do <code>?</code>). O servidor, por sua vez, recebe essa <code>url</code>, processa os parâmetros e retorna uma página HTML para o navegador.</p>
<p>A requisição <strong>POST</strong>, no entanto, envia uma <code>url</code> não modificada para o servidor, mas envia também uma lista de dados preenchidos pelo usuário, que podem ser números, textos ou até imagens. Na maioria dos casos, ao submeter um formulário de um site, fazemos uma requisição POST.</p>
<p>O <code>httr</code> possui os métodos <code>GET</code> e <code>POST</code> implementados e são muito similares. A lista de parâmetros enviados pelo usuário pode ser armazenado numa <code>list</code> nomeada, e adicionado ao <code>GET</code> pelo parâmetro <code>query</code> ou no <code>POST</code> pelo parâmetro <code>body</code>. Veremos exemplos disso mais adiante.</p>
</div>
<div id="outras-funcoes-do-httr" class="section level3">
<h3>Outras funções do <code>httr</code></h3>
<p>Outras funções úteis:</p>
<ul>
<li><code>write_disk()</code> para escrever uma requisição direto em disco, além de guardar na memória RAM.</li>
<li><code>config()</code> para adicionar configurações adicionais. Por exemplo, quando acessar uma página <code>https</code> com certificados inadequados numa requisição GET, rode <code>GET('https://www...', config(ssl_verifypeer=F))</code>.</li>
<li><code>oauth_app()</code> para trabalhar com APIs. Não discutiremos conexão com APIs nesse curso, mas é um importante conceito a ser estudado.</li>
</ul>
</div>
<div id="principais-funcoes-do-rvest" class="section level3">
<h3>Principais funções do <code>rvest</code></h3>
<pre class="r"><code>library(rvest)</code></pre>
<pre><code>## Loading required package: xml2</code></pre>
<pre class="r"><code>library(ggplot2)</code></pre>
<p><strong>Para acessar páginas da web:</strong></p>
<ul>
<li><code>html_session()</code> abre uma sessão do usuário (baixa página, carrega cookies etc).</li>
<li><code>follow_link()</code>, <code>jump_to()</code> acessa uma página web a partir de um link (tag <code>&lt;a&gt;</code>) ou url.</li>
<li><code>html_form()</code> carrega todos os formulários contidos numa página.</li>
<li><code>set_value()</code> atribui valores a parâmetros do formulário.</li>
<li><code>submit_form()</code> submete um formulário obtido em <code>html_form</code>.</li>
</ul>
<p><strong>Para trabalhar com arquivos HTML:</strong></p>
<ul>
<li><code>read_html()</code> lê o arquivo HTML de forma estruturada e facilita impressão.</li>
<li><code>html_nodes()</code> cria uma lista com os nós identificados por uma busca em CSS path ou XPath.</li>
<li><code>html_node()</code> é um caso especial que assume que só será encontrado um resultado.</li>
<li><code>html_text()</code> extrai todo o conteúdo de um objeto e retorna um texto.</li>
<li><code>html_table()</code> extrai o conteúdo de uma <code>&lt;table&gt;</code> e transforma em um <code>data_frame</code>.</li>
<li><code>html_attr()</code> extrai um atributo de uma tag, por exemplo <code>href</code> da tag <code>&lt;a&gt;</code>.</li>
</ul>
</div>
<div id="css-path-e-xpath" class="section level3">
<h3>CSS path e XPath</h3>
<p>O CSS path e o XPath são formas distintas de buscar tags dentro de um documento HTML. O CSS path é mais simples de implementar e tem uma sintaxe menos verborrágica, mas o XPath é mais poderoso. A regra de bolso é tentar fazer a seleção primeiro em CSS e, caso não seja possível, implementar em XPath.</p>
<p>Esses paths serão mostrados <em>en passant</em> durante o curso, mas não serão abordados em detalhe. Caso queira se aprofundar no assunto, comece pela ajuda da função <code>?html_nodes</code>.</p>
</div>
<div id="apis-com-httr" class="section level3">
<h3>APIs com <code>httr</code></h3>
<p>O <code>httr</code> foi criado pensando-se nas modernas APIs que vêm sendo desenvolvidas nos últimos anos. O <code>httr</code> já tem métodos apropriados para trabalhar com Facebook, Twitter e Google, entre outros.</p>
<p>Para um guia completo de como utilizar APIs no R, acesse <a href="https://cran.r-project.org/web/packages/httr/vignettes/api-packages.html">esse tutorial</a>. Um exemplo de pacote que utiliza API usando esse tutorial melhores práticas pode ser <a href="https://github.com/jtrecenti/sptrans">acessado aqui</a>.</p>
<hr />
</div>
</div>
<div id="exemplo-1-chance-de-gol" class="section level1">
<h1>Exemplo 1: chance de gol</h1>
<div id="parte-0-pacotes" class="section level2">
<h2>Parte 0: pacotes</h2>
<pre class="r"><code>library(tibble)
library(httr)
library(rvest)
library(dplyr)</code></pre>
</div>
<div id="parte-1-acessando-a-pagina-de-um-ano" class="section level2">
<h2>Parte 1: acessando a página de um ano</h2>
<pre class="r"><code>ano &lt;- 2015
cdg_url &lt;- sprintf(&#39;http://www.chancedegol.com.br/br%02d.htm&#39;, ano - 2000)

cdg_html &lt;- cdg_url %&gt;%
  httr::GET() %&gt;%
  httr::content(&#39;text&#39;, encoding = &#39;latin1&#39;) %&gt;%
  xml2::read_html() %&gt;%
  rvest::html_node(&#39;table&#39;)</code></pre>
</div>
<div id="parte-2-cores-da-tabela" class="section level2">
<h2>Parte 2: cores da tabela</h2>
<pre class="r"><code>cores &lt;- cdg_html %&gt;%
  html_nodes(xpath = &#39;//font[@color=&quot;#FF0000&quot;]&#39;) %&gt;%
  html_text()</code></pre>
</div>
<div id="parte-3-nomes-e-estrutura-da-tabela" class="section level2">
<h2>Parte 3: nomes e estrutura da tabela</h2>
<pre class="r"><code>cdg_data &lt;- cdg_html %&gt;%
  html_table(header = TRUE) %&gt;%
  setNames(c(&#39;dt_jogo&#39;, &#39;mandante&#39;, &#39;placar&#39;, &#39;visitante&#39;,
             &#39;p_mandante&#39;, &#39;p_empate&#39;, &#39;p_visitante&#39;)) %&gt;% 
  mutate(p_vitorioso = cores) %&gt;% 
  as_tibble() %&gt;% 
  mutate(result = &#39;OK&#39;)</code></pre>
</div>
<div id="parte-4-colocando-dentro-de-uma-funcao" class="section level2">
<h2>Parte 4: colocando dentro de uma função</h2>
<pre class="r"><code>cdg_ano &lt;- function(ano) {
  cdg_url &lt;- sprintf(&#39;http://www.chancedegol.com.br/br%02d.htm&#39;, ano - 2000)
  
  cdg_html &lt;- cdg_url %&gt;%
    GET() %&gt;%
    content(&#39;text&#39;, encoding = &#39;latin1&#39;) %&gt;%
    read_html() %&gt;%
    html_node(&#39;table&#39;)
  
  cores &lt;- cdg_html %&gt;%
    html_nodes(xpath = &#39;//font[@color=&quot;#FF0000&quot;]&#39;) %&gt;%
    html_text()
  
  cdg_data &lt;- cdg_html %&gt;%
    html_table(header = TRUE) %&gt;%
    setNames(c(&#39;dt_jogo&#39;, &#39;mandante&#39;, &#39;placar&#39;, &#39;visitante&#39;,
               &#39;p_mandante&#39;, &#39;p_empate&#39;, &#39;p_visitante&#39;)) %&gt;% 
    mutate(p_vitorioso = cores) %&gt;% 
    as_tibble() %&gt;% 
    mutate(result = &#39;OK&#39;)
  
  cdg_data
}</code></pre>
</div>
<div id="parte-5-vetorizando-anos" class="section level2">
<h2>Parte 5: vetorizando anos</h2>
<pre class="r"><code>cdg_anos &lt;- function(anos) {
  cdg_ano_safe &lt;- failwith(tibble(result = &#39;erro&#39;), cdg_ano)
  anos %&gt;% 
    setNames(anos) %&gt;% 
    purrr::map_df(cdg_ano_safe, .id = &#39;ano&#39;)
}

d_cdg &lt;- cdg_anos(c(2014, 2015))
d_cdg</code></pre>
<hr />
</div>
</div>
<div id="exemplo-2-sabesp" class="section level1">
<h1>Exemplo 2: Sabesp</h1>
<div id="passo-0-pacotes" class="section level2">
<h2>Passo 0: pacotes</h2>
<pre class="r"><code>library(tibble)
library(httr)
library(rvest)
library(lubridate)
library(stringr)
library(purrr)
library(dplyr)</code></pre>
</div>
<div id="passo-1-acessa-pagina-principal" class="section level2">
<h2>Passo 1: acessa página principal</h2>
<pre class="r"><code>link &lt;- &#39;http://www2.sabesp.com.br/mananciais/DivulgacaoSiteSabesp.aspx&#39;
txt &lt;- GET(link)</code></pre>
</div>
<div id="passo-2-funcao-que-pega-viewstate-ou-eventvalidation-da-pagina" class="section level2">
<h2>Passo 2: função que pega viewstate ou eventvalidation da página</h2>
<pre class="r"><code># tipo pode ser &quot;#__VIEWSTATE&quot; ou &quot;#__EVENTVALIDATION&quot;
pegar_tags &lt;- function(req, tipo) {
  req %&gt;% 
    content(&#39;text&#39;) %&gt;% 
    read_html() %&gt;% 
    html_node(tipo) %&gt;% 
    html_attr(&#39;value&#39;)
}

# exemplo
viewstate &lt;- pegar_tags(txt, &quot;#__VIEWSTATE&quot;)
eventval &lt;- pegar_tags(txt, &quot;#__EVENTVALIDATION&quot;)</code></pre>
</div>
<div id="passo-3-dados-da-requisicao" class="section level2">
<h2>Passo 3: dados da requisição</h2>
<pre class="r"><code>sabesp_dados &lt;- function(data, vs, ev) {
  data &lt;- as.Date(data)
  dados &lt;- list(cmbDia = lubridate::day(data), 
                cmbMes = lubridate::month(data), 
                cmbAno = lubridate::year(data), 
                Imagebutton1.x = &#39;0&#39;, 
                Imagebutton1.y = &#39;0&#39;, 
                &#39;__VIEWSTATE&#39; = vs, 
                &#39;__EVENTVALIDATION&#39; = ev,
                &#39;__VIEWSTATEENCRYPTED&#39; = &#39;&#39;)
}

# exemplo
data &lt;- &#39;2017-02-14&#39;
form &lt;- sabesp_dados(data, viewstate, eventval)
# requisicao de busca
result &lt;- POST(link, body = form)</code></pre>
</div>
<div id="passo-4-pegar-nomes-dos-sistemas" class="section level2">
<h2>Passo 4: pegar nomes dos sistemas</h2>
<pre class="r"><code>sabesp_nm_sistemas &lt;- function(r) {
  nomes &lt;- r %&gt;% 
    content(&#39;text&#39;) %&gt;% 
    read_html() %&gt;% 
    html_nodes(&#39;img&#39;) %&gt;% 
    html_attr(&#39;src&#39;) %&gt;% 
    keep(~str_detect(.x, &#39;\\.gif$&#39;)) %&gt;% 
    map_chr(~str_match(.x, &#39;/(.+)\\.gif&#39;)[, 2])
  nomes
}

sabesp_nm_sistemas(result)</code></pre>
</div>
<div id="passo-5-pegar-conteudo-da-pagina" class="section level2">
<h2>Passo 5: pegar conteúdo da página</h2>
<pre class="r"><code>sabesp_conteudo &lt;- function(r) {
  nomes &lt;- sabesp_nm_sistemas(r)
  r %&gt;% 
    content(&#39;text&#39;) %&gt;% 
    read_html() %&gt;% 
    html_node(&#39;#tabDados&#39;) %&gt;% 
    html_table(fill = TRUE) %&gt;%
    select(titulo = X1, info = X2) %&gt;%
    filter(titulo != &#39;&#39;) %&gt;%
    mutate(lugar = rep(nomes, each = 4)) %&gt;% #View
    mutate(info = info %&gt;% 
             str_extract(&#39;[-0-9, %m]+$&#39;) %&gt;% 
             str_replace_all(&#39;^[^:]+:&#39;, &#39;&#39;) %&gt;% 
             str_replace_all(&#39;,&#39;, &#39;.&#39;) %&gt;% 
             str_replace_all(&#39;[^0-9.]&#39;, &#39;&#39;) %&gt;%
             as.numeric()) %&gt;% 
    as_tibble()
}

# exemplo
sabesp_conteudo(result)</code></pre>
</div>
<div id="passo-5-colocar-tudo-numa-funcao" class="section level2">
<h2>Passo 5: colocar tudo numa função</h2>
<pre class="r"><code>sabesp_dia &lt;- function(data) {
  link &lt;- &#39;http://www2.sabesp.com.br/mananciais/DivulgacaoSiteSabesp.aspx&#39;
  txt &lt;- GET(link)
  viewstate &lt;- pegar_tags(txt, &quot;#__VIEWSTATE&quot;)
  eventval &lt;- pegar_tags(txt, &quot;#__EVENTVALIDATION&quot;)
  form &lt;- sabesp_dados(data, viewstate, eventval)
  result &lt;- POST(link, body = form)
  d_res &lt;- sabesp_conteudo(result) %&gt;% 
    mutate(result = &#39;OK&#39;)
  return(d_res)
}

# exemplo
sabesp_dia(&#39;2017-02-14&#39;)</code></pre>
<pre class="r"><code>sabesp_dias &lt;- function(datas) {
  sabesp_dia_safe &lt;- failwith(tibble(result = &#39;erro&#39;), sabesp_dia)
  datas %&gt;% 
    setNames(as.character(datas)) %&gt;% 
    purrr::map_df(sabesp_dia_safe, .id = &#39;data&#39;)
}

# exemplo
dts &lt;- as.Date(&#39;2017-02-14&#39;) - lubridate::days(0:13 * 30)

d_sabesp &lt;- sabesp_dias(dts)

library(ggplot2)
d_sabesp %&gt;% 
  filter(titulo == &#39;volume armazenado&#39;) %&gt;% 
  mutate(data = ymd(data)) %&gt;% 
  ggplot( aes(x = data, y = info, colour = lugar)) +
  geom_line() +
  theme_bw()</code></pre>
<hr />
</div>
</div>
<div id="case-study-camaras-tjsp-jurimetria" class="section level1">
<h1>Case study: câmaras TJSP (jurimetria)</h1>
<div id="melhores-praticas-para-web-scraping" class="section level2">
<h2>Melhores práticas para web scraping</h2>
<p>Esta seção contém algumas melhores práticas na contrução de ferramentas no R que baixam e processam informações de sites disponíveis na web. O objetivo é ajudar o jurimetrista a desenvolver programas que sejam fáceis de adaptar no tempo.</p>
<p>É importante ressaltar que só estamos trabalhando com páginas que são acessíveis publicamente. Caso tenha interesse e “raspar” páginas que precisam de autenticação, recomendamos que estude os termos de uso do site.</p>
<p>Para ilustrar este texto, usaremos como exemplo o código utilizado no trabalho das câmaras, que acessa o site do Tribunal de Justiça de São Paulo para obter informações de processos judiciais. Trabalharemos principalmente com a <a href="https://esaj.tjsp.jus.br/cjsg/consultaCompleta.do">Consulta de Jurisprudência</a> e a <a href="https://esaj.tjsp.jus.br/cpo/sg/open.do">Consulta de de Processos de Segundo Grau</a> do TJSP.</p>
<p>Sugerimos como melhores práticas dividir todas as atividades em três tarefas principais: i) <em>buscar</em>; ii) <em>coletar</em> e iii) <em>processar</em>. Quando já sabemos de antemão quais são as URLs que vamos acessar, a etapa de busca é desnecessária.</p>
<p>Na maior parte dos casos, deixar os algoritmos de <em>coleta</em> e <em>processamento</em> dos dados em funções distintas é uma boa prática pois aumenta o controle sobre o que as ferramentas estão fazendo, facilita o debug e a atualização. Por outro lado, em alguns casos isso pode tornar o código mais ineficiente e os arquivos obtidos podem ficar pesados.</p>
<div id="diferenca-entre-buscar-baixar-e-processar." class="section level3">
<h3>Diferença entre buscar, baixar e processar.</h3>
<p>Buscar documentos significa, de uma forma geral, utilizar ferramentas de busca (ou acessar links de um site) para obter informações de uma nova requisição a ser realizada. Ou seja, essa etapa do scraper serve para “procurar links” que não sabíamos que existiam previamente. Isso será resolvido através da função <code>cjsg</code>.</p>
<p>Baixar documentos, no entando, significa simplesmente acessar páginas pré-estabelecidas e salvá-las em disco. Em algumas situações, os documentos baixados (depois de limpos) podem conter uma nova lista de páginas a serem baixadas, formando iterações de coletas. A tarefa de baixar documentos pré-estabelecidos será realizada pela função <code>cposg</code>.</p>
<p>Finalmente, processar documentos significa carregar dados acessíveis em disco e transformar os dados brutos uma base <em>tidy</em>. Usualmente separamos a estruturação em duas etapas: i) transformar arquivos não-estruturados em um arquivos semi-estruturados (e.g. um arquivo HTML em uma tabela mais um conjunto de textos livres) e ii) transformar arquivos semi-estruturados em uma base analítica (estruturada). A tarefa de processar as páginas HTML será realizada pelas funções <code>parse_cjsg</code> e <code>parse_cpopg</code>.</p>
<p>Na pesquisa das câmaras, seguimos o fluxo</p>
<pre><code>buscar -&gt; coletar -&gt; processar -&gt; coletar -&gt; processar</code></pre>
<p>para conseguir nossos dados.</p>
</div>
</div>
<div id="buscar-documentos" class="section level2">
<h2>Buscar documentos</h2>
<p>A tarefa de listar os documentos de interesse é realizada acessando resultados de um formulário. Dependendo do site, será necessário realizar:</p>
<ul>
<li>Uma busca e uma paginação;</li>
<li>Uma busca e muitas paginações;</li>
<li>Muitas buscas e uma paginação por busca;</li>
<li>Muitas buscas e muitas paginações por busca.</li>
</ul>
<p>No TJSP temos <em>uma busca e muitas paginações</em>. Acesse a página do <a href="http://esaj.tjsp.jus.br/cjsg/consultaCompleta.do">e-SAJ</a>, digite “acordam” no campo “Pesquisa Livre” e clique em “Pesquisar”, para ter uma ideia de como é essa página.</p>
<p>A página (acessada no dia 2017-02-22) é uma ferramenta de busca com vários campos, que não permite pesquisa com dados em branco. Na parte de baixo o site mostra uma série de documentos, organizados em páginas de vinte em vinte resultados.</p>
<p>Para realizar a coleta, precisamos de duas funções principais, uma que faz a busca e outra que acessa uma página específica (que será executada várias vezes). Utilizaremos as funções <code>cjsg</code> e <code>cjsg_pag</code>.</p>
<pre class="r"><code>cjsg_session &lt;- function() {
  rvest::html_session(&#39;http://esaj.tjsp.jus.br/cjsg/consultaCompleta.do&#39;)
}</code></pre>
<pre class="r"><code>cjsg &lt;- function(s, parms = cjsg_parms(s), path = &#39;./cjsg&#39;, 
                 max_pag = 10, overwrite = FALSE,
                 verbose = TRUE, p = .05) {
  
  dir.create(path, recursive = TRUE, showWarnings = FALSE)
  
  if (!file.exists(path)) stop(sprintf(&#39;Pasta não &quot;%s&quot; pôde ser criada&#39;, path))
  
  r0 &lt;- s %&gt;% 
    rvest::submit_form(parms)
  
  n_pags &lt;- if (is.na(max_pag) || is.infinite(max_pag)) cjsg_npags(r0) else max_pag
  
  abjutils::dvec(cjsg_pag, 
                 1:n_pags, 
                 path = path, 
                 ow = overwrite, 
                 s = s)
}</code></pre>
<pre class="r"><code>cjsg_pag &lt;- function(pag, path, ow, s) {
  Sys.sleep(1)
  u &lt;- &#39;http://esaj.tjsp.jus.br/cjsg/trocaDePagina.do?tipoDeDecisao=A&amp;pagina=%d&#39;
  u_pag &lt;- sprintf(u, pag)
  arq &lt;- sprintf(&#39;%s/%05d.html&#39;, path, pag)
  if (!file.exists(arq) || ow) {
    
    httr::GET(u_pag, 
              httr::write_disk(arq, overwrite = ow), 
              handle = s$handle)
    
    tibble::data_frame(result = &#39;OK&#39;)
  } else {
    tibble::data_frame(result = &#39;já existe&#39;)
  }
}</code></pre>
<p>A função <code>cjsg_pag</code> precisa ser capaz de realizar uma pesquisa e retornar a resposta do servidoe que contém a primeira página dos resultados. Para isso, ela recebe uma lista com dados da busca (do formulário) a url base e um método para realizar a requisição, podendo ser ‘get’ ou ‘post’. Caso a pesquisa seja mais complicada, é possível adicionar também uma função que sobrepõe a busca padrão.</p>
<p>É possível visualizar a página baixada com a função <code>BROWSE</code> do pacote <code>httr</code>.</p>
<pre class="r"><code>arqs &lt;- dir(&#39;data-raw/cjsg&#39;, full.names = TRUE)
httr::BROWSE(arqs[1])</code></pre>
<p><strong>OBS:</strong> A imagem fica “feia” pois está sem a folha de estilos e as imagens.</p>
<p>Note que criamos uma função que facilita a entrada de parâmetros de busca. No nosso exemplo, existem parâmetros necessários na requisição que não precisam ser preenchidos, e parâmetros que precisam ser preenchidos de uma maneira específica, como as datas, que precisam ser inseridas no formato <code>%d/%m/%Y</code>. Assim, incluimos uma função de “ajuda”.</p>
<pre class="r"><code>cjsg_parms &lt;- function(s, livre = &#39;&#39;, data_inicial = NULL, data_final = NULL, secoes = &#39;&#39;) {
  secoes &lt;- paste(secoes, collapse = &#39;,&#39;)
  dt_inicial &lt;- &#39;&#39;
  if (!is.null(data_inicial)) {
    dt_inicial &lt;- sprintf(&#39;%02d/%02d/%d&#39;, lubridate::day(data_inicial),
                          lubridate::month(data_inicial),
                          lubridate::year(data_inicial))
  }
  dt_final &lt;- &#39;&#39;
  if (!is.null(data_final)) {
    dt_final &lt;- sprintf(&#39;%02d/%02d/%d&#39;, lubridate::day(data_final),
                        lubridate::month(data_final),
                        lubridate::year(data_final))
  }
  suppressWarnings({
    s %&gt;% 
      rvest::html_form() %&gt;% 
      dplyr::first() %&gt;% 
      rvest::set_values(&#39;dados.buscaInteiroTeor&#39; = livre,
                        &#39;secoesTreeSelection.values&#39; = secoes,
                        &#39;dados.dtJulgamentoInicio&#39; = dt_inicial,
                        &#39;dados.dtJulgamentoFim&#39; = dt_final)
  })
}</code></pre>
<p>Também foi necessário realizar um pequeno processamento na primeira requisição, quando o usuário não souber a priori quantas páginas deseja baixar. Nesse caso, a função <code>cjsg_npags</code> identifica o número de paginações necessárias.</p>
<pre class="r"><code>cjsg_npags &lt;- function(req, parms = NULL) {
  if (!is.null(parms)) req &lt;- req %&gt;% rvest::submit_form(parms)
  num &lt;- req$response %&gt;% 
    httr::content(&#39;text&#39;) %&gt;% 
    xml2::read_html() %&gt;%
    rvest::html_node(&#39;#nomeAba-A&#39;) %&gt;% 
    rvest::html_text() %&gt;% 
    tidyr::extract_numeric()
  (num %/% 20) + 1
}</code></pre>
<p>A função <code>dvec</code> é uma função genérica que ajuda a aplicar uma função a cada elemento de determinados itens, como um <code>lapply</code>, mas que o faz de forma mais verborrágica e não resulta em erro caso um elemento dê erro.</p>
<pre class="r"><code>#&#39; Vetorizando scrapers
#&#39;
#&#39; Vetoriza um scraper (função) para um vetor de itens
#&#39;
#&#39; @param fun função a ser aplicada em cada arquivo.
#&#39; @param itens character vector dos caminhos de arquivos a serem transformados.
#&#39; @param ... outros parâmetros a serem passados para \code{fun}
#&#39; @param verbose se \code{TRUE} (default), mostra o item com probabilidade p.
#&#39; @param p probabilidade de imprimir mensagem.
#&#39; 
#&#39; @export
dvec &lt;- function(fun, itens, ..., verbose = TRUE, p = .05) {
  f &lt;- dplyr::failwith(tibble::data_frame(result = &#39;erro&#39;), fun)
  tibble::data_frame(item = itens) %&gt;%
    dplyr::distinct(item) %&gt;%
    dplyr::group_by(item) %&gt;%
    dplyr::do({
      if (runif(1) &lt; p &amp;&amp; verbose) print(.$item)
      d &lt;- f(.$item, ...)
      if (tibble::has_name(d, &#39;result&#39;)) d$result &lt;- &#39;OK&#39;
      d
    }) %&gt;%
    dplyr::ungroup()
}</code></pre>
<p>No projeto das câmaras, rodamos o seguinte código:</p>
<pre class="r"><code># devtools::install_github(&#39;abjur/abjutils&#39;)

library(tjsp)

sec &lt;- list_secoes_2inst() %&gt;% 
  dplyr::filter(stringr::str_detect(secao, &#39;[Cc]rim&#39;),
                stringr::str_detect(pai, &#39;CRIM&#39;)) %&gt;% 
  with(cod)

session &lt;- cjsg_session()
parms &lt;- session %&gt;% 
  cjsg_parms(secoes = sec, 
             data_inicial = &#39;2015-01-01&#39;, 
             data_final = &#39;2015-12-31&#39;)

# numero de paginas a serem baixadas
session %&gt;% cjsg_npags(parms)

d_result &lt;- session %&gt;% 
  cjsg(parms, path = &#39;data-raw/cjsg&#39;, max_pag = 10)</code></pre>
<p><strong>Onde guardar os dados?</strong> Ao construir um scraper, é importante guardar os dados brutos na máquina ou num servidor, para reprodutibilidade e manutenção do scraper. Se estiver construindo um pacote do R, o melhor lugar para guardar esses dados é na pasta <code>data-raw</code>, como sugerido no livro <a href="http://r-pkgs.had.co.nz">r-pkgs</a>.</p>
<p>Se os dados forem muito volumosos, pode ser necessário colocar esses documentos numa pasta externa ao pacote. Para garantir a reprodutibilidade, recomendamos a criação de um pacote no R cujo objetivo é somente baixar e processar esses dados, além da criação de um repositório na nuvem (Dropbox, por exemplo). No pacote que contém as funções de extração, guarde os dados já processados (se couberem) num arquivo <code>.rda</code> dentro da pasta <code>data</code> do pacote.</p>
</div>
<div id="coletar-processos" class="section level2">
<h2>Coletar processos</h2>
<p>Antes de coletar os processos, é necessário ler os arquivos HTML baixados na etapa anterior.</p>
<pre class="r"><code>parse_cjsg_um &lt;- function(i, nodes) {
  node &lt;- nodes[[i]]
  trim &lt;- stringr::str_trim
  id &lt;- node %&gt;%
    rvest::html_node(&#39;.ementaClass&#39;) %&gt;%
    rvest::html_text() %&gt;%
    trim() %&gt;%
    stringr::str_replace_all(&#39;[^0-9]&#39;, &#39;&#39;)
  infos &lt;- node %&gt;%
    rvest::html_node(&#39;.downloadEmenta&#39;) %&gt;% {
      tibble::tibble(n_processo = trim(rvest::html_text(.)),
                     cd_acordao = rvest::html_attr(., &#39;cdacordao&#39;))
    }
  ca &lt;- node %&gt;%
    rvest::html_node(&#39;.assuntoClasse&#39;) %&gt;%
    rvest::html_text() %&gt;%
    trim()
  tsf &lt;- node %&gt;%
    rvest::html_node(&#39;textarea&#39;) %&gt;%
    rvest::html_text()
  tab_infos &lt;- node %&gt;%
    rvest::html_nodes(&#39;.ementaClass2&#39;) %&gt;%
    rvest::html_text() %&gt;%
    stringr::str_split_fixed(&#39;:&#39;, 2) %&gt;%
    data.frame(stringsAsFactors = FALSE) %&gt;%
    setNames(c(&#39;key&#39;, &#39;val&#39;)) %&gt;%
    dplyr::mutate_all(dplyr::funs(trim(.))) %&gt;%
    dplyr::mutate(key = tolower(abjutils::rm_accent(key)),
                  key = stringr::str_replace_all(key, &#39; +&#39;, &#39;_&#39;),
                  key = stringr::str_replace_all(key, &#39;[^a-z_]&#39;, &#39;&#39;),
                  key = stringr::str_replace_all(key, &#39;_d[eo]_&#39;, &#39;_&#39;)) %&gt;%
    tidyr::spread(key, val) %&gt;%
    dplyr::bind_cols(infos) %&gt;%
    dplyr::mutate(id = id, classe_assunto = ca, txt_ementa = tsf) %&gt;%
    dplyr::select(id, cd_acordao, n_processo, dplyr::everything(), txt_ementa)
  tab_infos
}

parse_cjsg_arq &lt;- function(arq) {
  itens &lt;- xml2::read_html(arq, encoding = &#39;UTF-8&#39;) %&gt;%
    rvest::html_nodes(&#39;.fundocinza1&#39;)
  abjutils::dvec(parse_cjsg_um, 1:length(itens), nodes = itens, verbose = FALSE) %&gt;%
    dplyr::select(-item)
}

parse_cjsg &lt;- function(arqs) {
  abjutils::dvec(parse_cjsg_arq, arqs) %&gt;%
    dplyr::rename(arq = item)
}</code></pre>
<p>Rodando a função criada.</p>
<pre class="r"><code>arqs &lt;- dir(&#39;data-raw/cjsg&#39;, full.names = TRUE)
d_cjsg &lt;- tjsp::parse_cjsg(arqs)
saveRDS(d_cjsg, &#39;data-raw/d_cjsg.rds&#39;)</code></pre>
<pre class="r"><code>d_cjsg &lt;- readRDS(&#39;data-raw/d_cjsg.rds&#39;)
d_cjsg</code></pre>
<pre><code>## # A tibble: 200 × 14
##                         arq    id cd_acordao                n_processo
##                       &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;                     &lt;chr&gt;
## 1  data-raw/cjsg/00001.html     1   10120659 0053149-48.2006.8.26.0050
## 2  data-raw/cjsg/00001.html     2   10092189 0011582-56.2009.8.26.0236
## 3  data-raw/cjsg/00001.html     3   10040923 0035263-74.2015.8.26.0000
## 4  data-raw/cjsg/00001.html     4   10039029 0019944-66.2015.8.26.0000
## 5  data-raw/cjsg/00001.html     5   10039023 0041547-98.2015.8.26.0000
## 6  data-raw/cjsg/00001.html     6   10027377 0003710-93.2014.8.26.0048
## 7  data-raw/cjsg/00001.html     7    9983410 7004537-07.2015.8.26.0482
## 8  data-raw/cjsg/00001.html     8    9956156 0004870-37.2014.8.26.0604
## 9  data-raw/cjsg/00001.html     9    9901809 7007051-30.2015.8.26.0482
## 10 data-raw/cjsg/00001.html    10    9899013 0087445-23.2011.8.26.0050
## # ... with 190 more rows, and 10 more variables: comarca &lt;chr&gt;,
## #   data_julgamento &lt;chr&gt;, data_registro &lt;chr&gt;, ementa &lt;chr&gt;,
## #   orgao_julgador &lt;chr&gt;, relatora &lt;chr&gt;, classe_assunto &lt;chr&gt;,
## #   txt_ementa &lt;chr&gt;, result &lt;chr&gt;, outros_numeros &lt;chr&gt;</code></pre>
<p>Agora criamos a função que baixa processos.</p>
<pre class="r"><code>dados_cposg &lt;- function(p) {
  list(&#39;conversationId&#39; = &#39;&#39;,
       &#39;paginaConsulta&#39; = &#39;1&#39;,
       &#39;localPesquisa.cdLocal&#39; = &#39;-1&#39;,
       &#39;cbPesquisa&#39; = &#39;NUMPROC&#39;,
       &#39;tipoNuProcesso&#39; = &#39;UNIFICADO&#39;,
       &#39;numeroDigitoAnoUnificado&#39; = stringr::str_sub(p, 1, 11),
       &#39;foroNumeroUnificado&#39; = stringr::str_sub(p, -4, -1),
       &#39;dePesquisaNuUnificado&#39; = p,
       &#39;dePesquisaNuAntigo&#39; = &#39;&#39;)
}

cposg_um &lt;- function(p, path, ow) {
  Sys.sleep(1)
  arq &lt;- sprintf(&#39;%s/%s.html&#39;, path, p)
  if (!file.exists(arq) || ow) {
    httr::GET(&#39;https://esaj.tjsp.jus.br/cposg/search.do&#39;,
              query = dados_cposg(p),
              config = httr::config(ssl_verifypeer = FALSE),
              httr::write_disk(arq, overwrite = ow))
    tibble::tibble(result = &#39;OK&#39;)
  } else {
    tibble::tibble(result = &#39;já existe&#39;)
  }
}

cposg &lt;- function(processos, path = &#39;data-raw/cposg&#39;, overwrite = FALSE) {
  suppressWarnings(dir.create(path, recursive = TRUE))
  processos &lt;- gsub(&#39;[^0-9]&#39;, &#39;&#39;, processos)
  abjutils::dvec(cposg_um, processos, path = path, ow = overwrite)
}</code></pre>
<p>Rodando a função criada.</p>
<pre class="r"><code>d_cjsg %&gt;% 
  distinct(n_processo) %&gt;% 
  with(n_processo) %&gt;% 
  tjsp::cposg()</code></pre>
<p>Extraindo as partes do arquivo HTML.</p>
<pre class="r"><code>partes_cposg_um &lt;- function(arq) {
  h &lt;- arq %&gt;% xml2::read_html(encoding = &#39;UTF-8&#39;)
  todas_partes &lt;- h %&gt;% rvest::html_nodes(&#39;#tableTodasPartes&#39;) %&gt;% length()
  if (todas_partes &gt; 0) {
    nodes &lt;- h %&gt;% 
      rvest::html_nodes(&#39;#tableTodasPartes &gt; .fundoClaro&#39;)
  } else {
    nodes &lt;- h %&gt;% 
      rvest::html_nodes(&#39;#tablePartesPrincipais &gt; .fundoClaro&#39;)
  }
  purrr::map_df(seq_along(nodes), function(i) {
    node &lt;- nodes[[i]]
    titulos &lt;- node %&gt;% 
      rvest::html_nodes(&#39;.mensagemExibindo&#39;) %&gt;% 
      rvest::html_text() %&gt;% 
      stringr::str_trim() %&gt;% 
      stringr::str_replace_all(&#39;&amp;nbsp&#39;, &#39;&#39;)
    tirar &lt;- paste(titulos, collapse = &#39;|&#39;)
    nomes &lt;- titulos %&gt;% 
      tolower() %&gt;% 
      abjutils::rm_accent() %&gt;% 
      stringr::str_replace_all(&#39;[^a-z]&#39;, &#39;&#39;) %&gt;% 
      paste(sprintf(&#39;%02d&#39;, 1:length(.)), sep = &#39;_&#39;)
    node %&gt;% 
      rvest::html_text() %&gt;% 
      stringr::str_trim() %&gt;% 
      stringr::str_replace_all(&#39;&amp;nbsp&#39;, &#39;&#39;) %&gt;% 
      stringr::str_replace_all(tirar, &#39;&#39;) %&gt;% 
      stringr::str_trim() %&gt;%
      stringr::str_split(&#39;[\n\t\r ]{2,}&#39;, simplify = TRUE) %&gt;% 
      data.frame(stringsAsFactors = FALSE) %&gt;% 
      setNames(nomes) %&gt;% 
      tidyr::gather() %&gt;% 
      tibble::as_data_frame() %&gt;% 
      tidyr::separate(key, c(&#39;tipo&#39;, &#39;id_tipo&#39;), sep = &#39;_&#39;) %&gt;% 
      dplyr::mutate(id = i) %&gt;% 
      dplyr::select(id, id_tipo, tipo, nome = value) %&gt;% 
      dplyr::mutate(result = &#39;OK&#39;)
  })
}

partes_cposg &lt;- function(arqs, verbose = FALSE) {
  abjutils::dvec(partes_cposg_um, arqs, verbose = verbose) %&gt;% 
    rename(arq = item)
}</code></pre>
<pre class="r"><code>arqs &lt;- dir(&#39;data-raw/cposg&#39;, full.names = TRUE)
d_partes &lt;-  partes_cposg(arqs)
saveRDS(d_partes, &#39;data-raw/d_partes.rds&#39;)
d_partes</code></pre>
<pre class="r"><code>d_partes &lt;- readRDS(&#39;data-raw/d_partes.rds&#39;)
d_partes</code></pre>
<pre><code>## # A tibble: 762 × 6
##                                         arq    id id_tipo     tipo
##                                       &lt;chr&gt; &lt;int&gt;   &lt;chr&gt;    &lt;chr&gt;
## 1  data-raw/cposg/00000179520148260050.html     1      01 apteapdo
## 2  data-raw/cposg/00000179520148260050.html     2      01 apdoapte
## 3  data-raw/cposg/00000179520148260050.html     2      02 advogado
## 4  data-raw/cposg/00000179520148260050.html     3      01 apdoapte
## 5  data-raw/cposg/00000179520148260050.html     3      02 advogado
## 6  data-raw/cposg/00000201120148260451.html     1      01 apelante
## 7  data-raw/cposg/00000201120148260451.html     1      02 advogado
## 8  data-raw/cposg/00000201120148260451.html     2      01  apelado
## 9  data-raw/cposg/00000636120138260457.html     1      01 apelante
## 10 data-raw/cposg/00000636120138260457.html     1      02 advogado
## # ... with 752 more rows, and 2 more variables: nome &lt;chr&gt;, result &lt;chr&gt;</code></pre>
<p>Extraindo as decisões.</p>
<pre class="r"><code>decisoes_cposg_um &lt;- function(arq) {
  html &lt;- xml2::read_html(arq, encoding = &#39;UTF-8&#39;)
  xpath &lt;- &#39;(//table[@width=&quot;98%&quot; and @align=&quot;center&quot;])[last()]&#39;
  r &lt;- rvest::html_node(html, xpath = xpath)
  tab &lt;- rvest::html_table(r)
  names(tab) &lt;- c(&#39;data&#39;, &#39;situacao&#39;, &#39;decisao&#39;)
  tab$result &lt;- &#39;OK&#39;
  return(tab)
}

decisoes_cposg &lt;- function(arqs, verbose = FALSE) {
  abjutils::dvec(decisoes_cposg_um, arqs, verbose = verbose) %&gt;% 
    dplyr::rename(arq = item)
}</code></pre>
<pre class="r"><code>arqs &lt;- dir(&#39;data-raw/cposg&#39;, full.names = TRUE)
d_decisoes &lt;- decisoes_cposg(arqs)
saveRDS(d_decisoes, &#39;data-raw/d_decisoes.rds&#39;)
d_decisoes</code></pre>
<pre class="r"><code>d_decisoes &lt;- readRDS(&#39;data-raw/d_decisoes.rds&#39;)
d_decisoes</code></pre>
<pre><code>## # A tibble: 361 × 5
##                                         arq       data
##                                       &lt;chr&gt;      &lt;chr&gt;
## 1  data-raw/cposg/00000179520148260050.html 16/12/2015
## 2  data-raw/cposg/00000201120148260451.html 03/12/2015
## 3  data-raw/cposg/00000636120138260457.html 08/10/2015
## 4  data-raw/cposg/00000636120138260457.html 24/09/2015
## 5  data-raw/cposg/00000636120138260457.html 17/09/2015
## 6  data-raw/cposg/00000681720138260576.html 16/12/2015
## 7  data-raw/cposg/00001064420148260495.html 03/12/2015
## 8  data-raw/cposg/00001241620138260361.html 29/10/2015
## 9  data-raw/cposg/00001939320158260000.html 12/05/2015
## 10 data-raw/cposg/00001939320158260000.html 14/04/2015
## # ... with 351 more rows, and 3 more variables: situacao &lt;chr&gt;,
## #   decisao &lt;chr&gt;, result &lt;chr&gt;</code></pre>
<p>Visualizando!</p>
<pre class="r"><code>tipos_decisao &lt;- function(decisoes) {
  negaram &lt;- regex(&#39;negaram&#39;, ignore_case = TRUE)
  parcial &lt;- regex(&#39;parcial&#39;, ignore_case = TRUE)
  deram &lt;- regex(&#39;deram&#39;, ignore_case = TRUE)
  ifelse(
    str_detect(decisoes, negaram), &#39;negado&#39;, ifelse(
      str_detect(decisoes, parcial), &#39;parcial&#39;, ifelse(
        str_detect(decisoes, deram), &#39;provido&#39;, &#39;outros&#39;
    ))
  )
}

partes_apelacoes &lt;- d_partes %&gt;% 
  filter(tipo == &#39;apelado&#39;, str_detect(nome, &#39;[Mm]inist&#39;)) %&gt;% 
  mutate(n_processo = str_replace_all(arq, &#39;[^0-9]&#39;, &#39;&#39;)) %&gt;% 
  dplyr::select(n_processo)

decisoes &lt;- d_decisoes %&gt;% 
  mutate(n_processo = str_replace_all(arq, &#39;[^0-9]&#39;, &#39;&#39;)) %&gt;% 
  inner_join(partes_apelacoes, &#39;n_processo&#39;) %&gt;% 
  filter(situacao == &#39;Julgado&#39;) %&gt;% 
  distinct(n_processo, decisao) %&gt;%
  mutate(tipo_decisao = tipos_decisao(decisao)) %&gt;% 
  dplyr::select(n_processo, tipo_decisao)

d_cjsg %&gt;%
  mutate(n_processo = str_replace_all(n_processo, &#39;[^0-9]&#39;, &#39;&#39;)) %&gt;% 
  inner_join(decisoes, &#39;n_processo&#39;) %&gt;% 
  filter(tipo_decisao != &#39;outros&#39;) %&gt;% 
  dplyr::count(orgao_julgador, tipo_decisao) %&gt;%
  mutate(ntot = sum(n), prop = n / ntot) %&gt;%
  filter(ntot &gt; 5) %&gt;% 
  ungroup() %&gt;%
  mutate(num = readr::parse_number(orgao_julgador),
         num = sprintf(&#39;%02d&#39;, num)) %&gt;% 
  ggplot(aes(x = num, fill = tipo_decisao, y = prop)) +
  geom_bar(stat = &#39;identity&#39;, colour = &#39;black&#39;, position = &#39;dodge&#39;) +
  theme_bw() +
  scale_y_continuous(labels = scales::percent) +
  xlab(&#39;Órgão julgador&#39;) +
  ylab(&#39;Proporção de processos por tipo de decisão&#39;) +
  theme(legend.position = &quot;bottom&quot;)</code></pre>
<p><img src="aula8_files/figure-html/unnamed-chunk-36-1.png" width="672" /></p>
</div>
<div id="sign-off" class="section level2">
<h2>Sign off</h2>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
